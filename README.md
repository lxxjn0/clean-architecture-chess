# clean-architecture-chess

> 클린 아키텍처를 학습한 후 Hexagonal Architecture로 체스 게임을 구현/리팩터링 한다.

## Step 01. Console Application 구현하기

### 기능 요구 사항

- 콘솔 UI에서 체스 게임을 할 수 있는 기능을 구현한다.
- 1단계는 체스 게임을 할 수 있는 체스판을 초기화한다.
- 체스판에서 말의 위치 값은 가로 위치는 왼쪽부터 a ~ h이고, 세로는 아래부터 위로 1 ~ 8로 구현한다.
- 체스판에서 각 진영은 검은색(대문자)과 흰색(소문자) 편으로 구분한다.
- 체스 말의 이동 규칙을 찾아보고 체스 말이 이동할 수 있도록 구현한다.
- `move source위치 target위치`을 실행해 이동한다.
- 체스 게임은 상대편 King이 잡히는 경우 게임에서 진다. King이 잡혔을 때 게임을 종료해야 한다.
- 체스 게임은 현재 남아 있는 말에 대한 점수를 구할 수 있어야 한다.
- `status` 명령을 입력하면 각 진영의 점수를 출력하고 어느 진영이 이겼는지 결과를 볼 수 있어야 한다.

### 점수 계산 규칙

- 체스 프로그램에서 현재까지 남아 있는 말에 따라 점수를 계산할 수 있어야 한다.
- 각 말의 점수는 queen은 9점, rook은 5점, bishop은 3점, knight는 2.5점이다.
- pawn의 기본 점수는 1점이다. 하지만 같은 세로줄에 같은 색의 폰이 있는 경우 1점이 아닌 0.5점을 준다.
- king은 잡히는 경우 경기가 끝나기 때문에 점수가 없다.
- 한 번에 한 쪽의 점수만을 계산해야 한다.

```
> 체스 게임을 시작합니다.
> 게임 시작 : start
> 게임 종료 : end
> 게임 이동 : move source위치 target위치 - 예. move b2 b3
start
RNBQKBNR
PPPPPPPP
........
........
........
........
pppppppp
rnbqkbnr

move b2 b3
RNBQKBNR
PPPPPPPP
........
........
........
.p......
p.pppppp
rnbqkbnr
```

## Step 02. Hexagonal Architecture로 리팩터링 하기

## Step 03. Spring Framework 적용하기

## 개발 관련 내용 정리

### 체스 도메인 분석

#### 체스 보드 (chess board)

- 총 64칸
- 세로줄은 file, 가로줄은 rank라고 명칭
- 보드의 밝은 색의 칸이 자신의 오른쪽 아래에 오도록 함
- 관례적으로 흑이 위에 앉음

#### 체스 기물 (chess piece)

- 체스는 총 32개의 기물을 가지고 게임을 진행
  - 룩(rook), 나이트(knight), 비숍(bishop), 퀸(queen), 킹(king), 폰(pawn)
- 백을 기준으로 첫 랭크에 `룩, 나이트, 비숍, 퀸, 킹, 비숍, 나이트, 룩` 을 놓음
- 둘째 랭크에 폰을 놓음
- 백과 흑의 킹은 마주보게 놓아야 함
- 가치
  - 폰: 1
  - 비숍, 나이트: 3 (미션에서는 나이트가 2.5점)
  - 룩: 5
  - 퀸: 9
- 이동 방법
  - 폰
    - 전진만 가능하며 첫 회 한정 2칸을 전진할 수 있고, 이후부터는 1칸만 전진이 가능
    - 첫 이동에 앞에 다른 말이 있을 경우 뛰어넘을 수 없음
    - 공격은 전방 대각선으로만 가능
  - 나이트
    - 직선으로 두 칸 이동 후 옆으로 1칸 이동이 가능 (L자 이동)
    - 유일하게 기물을 뛰어넘을 수 있음
  - 비숍
    - 거리 제한없이 대각선으로 이동 가능
  - 룩
    - 거리 제한없이 가로, 세로로 이동 가능
  - 퀸
    - 거리 제한없이 가로, 세로, 대각선으로 이동 가능
  - 킹
    - 체크메이트를 당하지 않도록 보호해야 하는 말
    - 가로, 세로, 대각선으로 1칸 이동 가능

#### 경기 방법

- 상대방의 킹을 먼저 '체크메이트(checkmate)'하면 승리
- 상대방의 킹을 직접적으로 위협하는 것을 '체크(check)'라고 함
- 체크를 대응하는 방법
  - 킹을 이동시켜 피함
  - 공격하는 상대방의 말을 잡음
  - 체크 상태에 놓인 상대방의 행마로에 다른 말을 가로 놓음
- 상대방이 체크를 만들었다면 자신은 킹이 잡히지 않을 수를 반드시 둬야 함
- 킹이 체크를 해결할 방법이 없다면 체크메이트로 게임 끝
- 킹을 잡는 것 그 자체는 체스 보드 위에서 실현되지 않음
  - 체크메이트가 되는 그 즉시 게임이 종료됨
- 체크 상태에서 모르거나 체크 방어가 되는 말을 움직여서 체크 방어를 못하는 경우 무효
  - 수를 도로 무르게 함
  - 2번 잘못된 수를 두면 실격패
- 체스는 매 턴마다 반드시 말을 움직여야 함

#### 특수 행마법

- 캐슬링(castling)
  - 아래 3개의 조건을 만족할 경우 킹을 두 칸 옆으로 옮기고 룩을 킹의 반대편에 옮길 수 있음
    - 킹과 캐슬링을 하려는 룩 사이를 비워둬야 함
    - 캐슬링을 하려는 룩과 킹은 한 번도 이동한 적이 없어야 함
    - 킹이 위치한 칸과 이동할 칸이 공격 받지 않는 상태여야 함
      - 원래 위치, 캐슬링 방향으로 한 칸 옆 위치(거쳐가야 할 칸), 두 칸 옆 위치(목적지) 세 위치 중 하나라도 공격받는 중이라서 이동하는 킹이 체크 상태가 되는 경우 캐슬링을 할 수 없음
  - 킹을 먼저 캐슬링하려는 룩 쪽으로 두 칸 움직인 뒤 폰을 이동함
- 프로모션(promotion)
  - 폰이 상대방 진영 끝까지 전진했을 경우 그 폰은 폰과 킹을 제외한 다른 모든 기물 중 하나로 승격할 수 있음
  - 승진을 거절할 수 없음
  - 이미 존재하는 말의 생사 여부와 무관하게 얼마든지 변경할 수 있음
- 앙파상(en passant)
  - 폰끼리만 적용되는 특수 규칙
  - 상대방의 폰이 첫 이동으로 2칸을 전진했는데 그 바로 옆 칸에 자신의 폰이 있을 경우, 1칸만 이동한 것으로 간주하고 그대로 상대방의 폰을 잡을 수 있음
  - 잡은 후에는 반드시 상대편 폰의 뒷편인 대각선으로 이동해야 함
  - 앙파상은 상대가 폰을 2칸 움직인 직후에만 행하는 것이 가능, 차례를 1번 거른 후에는 앙파상으로 잡을 수 없음

#### 무승부

- 킹이 체크 상태에 있지 않음에도 둘 차례인 쪽이 합법적으로 움직일 방법이 없는 스테일메이트일 경우
  - 스테일메이트(stalemate)
    - 킹이 체크 상태가 아니면서 이번 차례에 스스로 체크가 되는 자충수 외에는 둘 수밖에 없는 상태
- 기물 부족으로 체크메이트를 만들기에 충분하지 않을 경우
- 똑같은 포지션이 3번이 발생했을 경우
- 게임 중에 똑같은 대국 상황이 적어도 5번 이상 나왔을 경우

#### 체크

- 체스에서 어떤 한 선수의 킹이 다른 체스 기물에 의하여 공격을 받을 때 사용하는 용어
- 자신의 킹을 스스로 체크 상태로 만들거나 체크 상태에도 실수로 체크 상태에서 벗어나지 않았다면, 해당 수는 무효가 되고 그 이전 상황으로 되돌림

#### 기보 표기법

- 파일은 좌에서 우로 영어 a부터 h까지, 세로행은 아래에서 위로 숫자 1부터 8까지
- e1은 첫째 줄의 5번째 열을 의미한다
- 킹은 K, 퀸은 Q, 비숍은 B, 나이트는 N, 룩은 R로 표기, 폰은 P이지만 거의 항상 생략

## 참고 자료

- [체스 - 나무위키](https://namu.wiki/w/%EC%B2%B4%EC%8A%A4)
- [지속 가능한 소프트웨어 설계 패턴: 포트와 어댑터 아키텍처 적용하기 - LINE Engineering](https://engineering.linecorp.com/ko/blog/port-and-adapter-architecture/)
- [DDD Lite@Spring](https://www.youtube.com/watch?v=TdyOH1xZpT8)
- [Hexagonal Architecture with Java and Spring](https://reflectoring.io/spring-hexagonal/)
- [woowacourse/java-chess - Github](https://github.com/woowacourse/java-chess)
